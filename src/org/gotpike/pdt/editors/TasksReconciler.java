package org.gotpike.pdt.editors;

import java.util.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.eclipse.core.resources.IMarker;
import org.eclipse.jface.preference.IPreferenceStore;
import org.eclipse.jface.text.BadLocationException;
import org.eclipse.jface.text.IDocument;
import org.eclipse.jface.text.IRegion;
import org.eclipse.jface.text.ITypedRegion;
import org.eclipse.jface.text.rules.FastPartitioner;
import org.eclipse.ui.IEditorInput;
import org.eclipse.ui.IFileEditorInput;
import org.eclipse.ui.texteditor.IDocumentProvider;
import org.gotpike.pdt.PDTPlugin;
import org.gotpike.pdt.parser.PikeSymbol;
import org.gotpike.pdt.preferences.ITaskTagConstants;
import org.gotpike.pdt.preferences.TaskTagPreferences;
import org.gotpike.pdt.util.MarkerUtil;


/**
 * Scans an edited Perl source file for task markers,
 * adding/removing corresponding IMarkers to/from the resource
 * representing the source file.
 * 
 * @author jploski
 */
public class TasksReconciler
{
    private static final String PDT_AUTOGENERATED = "pdt.autogenerated";
    
    private final PikeEditor editor;
    private Pattern[] TODO_PATTERNS;
    private boolean allowWhiteSpace;
    private MarkerUtil markerUtil;
    
    public TasksReconciler(PikeEditor editor)
    {
        this.editor = editor;
    }
    
    
    // TODO: this is a nasty waste of resources.
	public void reconcile() {
		
		IEditorInput input = (IEditorInput) editor.getEditorInput();
        if (!(input instanceof IFileEditorInput)) return;
        
        IDocumentProvider docProvider = editor.getDocumentProvider();
        if (docProvider == null) return;
        
        IDocument doc = docProvider.getDocument(input);
        if (doc == null) return;
        	
		ITypedRegion[] partitions = doc.getDocumentPartitioner().computePartitioning(0, doc.getLength());
	       
        markerUtil = new MarkerUtil(((IFileEditorInput) input).getFile());         
        markerUtil.clearAllUsedFlags(IMarker.TASK, PDT_AUTOGENERATED);

        IPreferenceStore store = PDTPlugin.getDefault().getPreferenceStore();        
        allowWhiteSpace = store.getBoolean(ITaskTagConstants.ID_WHITESPACE);
        initSearchPatterns(store);

		for (int i = 0; i < partitions.length; i++)
	    {
	    	// System.out.println("Reconciling...");
	    	reconcile(partitions[i]);
	    }
  	}
    
    public void reconcile(IRegion partition)
    {
        IEditorInput input = (IEditorInput) editor.getEditorInput();
        if (!(input instanceof IFileEditorInput)) return;
        
        IDocumentProvider docProvider = editor.getDocumentProvider();
        if (docProvider == null) return;
        
        IDocument doc = docProvider.getDocument(input);
        if (doc == null) return;
        
        FastPartitioner partitioner = (FastPartitioner) doc.getDocumentPartitioner();
        if (partitioner == null) return;
   
        	int offset = partition.getOffset();
        	ITypedRegion region = partitioner.getPartition(offset);
        	if(region.getType() == PartitionTypes.COMMENT)
        		parseComment(doc, region);

    }
    
    private void addTaskMarker(int start, int stop, int lineNumber, String text)
    {
        Map attributes = new HashMap(11);
        
        attributes.put(IMarker.CHAR_START, new Integer(start));
        attributes.put(IMarker.CHAR_END, new Integer(stop));
        attributes.put(IMarker.LINE_NUMBER, new Integer(lineNumber));
        attributes.put(IMarker.MESSAGE, text);
        attributes.put(PDT_AUTOGENERATED, new Integer(42));
        markerUtil.addMarker(attributes, IMarker.TASK);
    }
    
    private void initSearchPatterns(IPreferenceStore store)    
    {
        int flags =
            store.getBoolean(ITaskTagConstants.ID_IGNORE_CASE)
            ? Pattern.CASE_INSENSITIVE
            : 0;
        
        flags = Pattern.MULTILINE;
        
        String taskTagList = store.getString(ITaskTagConstants.ID_TASK_TAGS);
        String[] TODO_STRINGS = TaskTagPreferences.parseStringList(taskTagList);
        TODO_PATTERNS = new Pattern[TODO_STRINGS.length];
        
        for (int i = 0; i < TODO_STRINGS.length; i++)
        {
            // construct the search string
            StringBuffer buffy;
            
            buffy= new StringBuffer();
            buffy.append(".*\\Q");
            buffy.append(TODO_STRINGS[i]);
            buffy.append("\\E(.*?)(\\*/)?\\Z");
            
            TODO_PATTERNS[i] = Pattern.compile(buffy.toString(), flags);

        }   
    }
    
    private void parseComment(IDocument doc, ITypedRegion t)
    {
        for (int i = 0; i < TODO_PATTERNS.length; i++)
            parseComment(doc, t, TODO_PATTERNS[i]);
    }
    
    private void parseComment(IDocument doc, ITypedRegion t, Pattern todoPattern)
    {
    	
    	String text;
		try {
			text = doc.get(t.getOffset(), t.getLength());
			if(text==null) return;
			
		//System.out.println("parseComment: " + todoPattern.pattern() + ", " + text);
        Matcher m = todoPattern.matcher(text);
        if (!m.find()) return;
//        String todoText = text.substring(m.end()).trim();
        String todoText = m.group(1);

        if (todoText.length() > 0)
        {
 
        	int lineNumber = doc.getLineOfOffset(t.getOffset());
      //      System.out.println("match at "+ lineNumber);

        	if(!markerUtil.isMarkerPresent(
                IMarker.TASK,
                lineNumber,
                todoText,
                PDT_AUTOGENERATED,
                true))
            {
  //  System.out.println("adding");
        		addTaskMarker(
                    t.getOffset() + m.start(),
                    t.getOffset() + m.start() + m.group().length() + todoText.length(),
                    lineNumber,
                    todoText);
            }
        }

		} catch (BadLocationException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}


}
