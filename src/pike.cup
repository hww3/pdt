/* -*- c -*-
|| This file is part of Pike. For copyright information see COPYRIGHT.
|| Pike is distributed under GPL, LGPL and MPL. See the file COPYING
|| for more information.
|| $Id: pike.cup,v 1.18 2008-02-05 01:35:14 hww3 Exp $
*/
package org.gotpike.pdt.parser;

import java_cup.runtime.*;
import org.gotpike.pdt.model.SourceFile;
import org.gotpike.pdt.parser.Block;
import org.gotpike.pdt.parser.InheritItem;
import java.util.ArrayList;

parser code  {: 

  
  public SourceFile source;

  public void yyerror(String message)
  { 
	  PikeScanner scanner = (PikeScanner)getScanner();
	  String filename = (scanner.filename!=null)?scanner.filename:"-";
  //    int severity = 0;
      
  //    source.reportError(message, filename, (scanner.getYyline()+1), scanner.getYycolumn(), severity);
    
      message = filename + ":" + (scanner.getYyline()+1) + /*" " +scanner.getYycolumn() + */": " + message;
    
      report_error(message, null);
  }
  
  public void report_error(String message, Object info) {
    StringBuffer m = new StringBuffer("Parser Error");

	  PikeScanner scanner = (PikeScanner)getScanner();
	  String filename = (scanner.filename!=null)?scanner.filename:"-";
      int severity = 0;
      
      // TODO: report the token location instead of the lexer location.
      source.reportError(message, filename, (scanner.getYyline()+1), scanner.getYycolumn(), severity);


    if (info instanceof java_cup.runtime.Symbol) 
      m.append( "(" +info.toString()+")" );
     
    m.append(": "+message);
   
    System.out.println(m);
  }
   
  public void report_fatal_error(String message, Object info) {
    report_error(message, info);
    throw new RuntimeException("Fatal Syntax Error");
  }
:};

terminal TOK_ARROW ;

/*
 * Basic value pushing
 */
terminal TOK_CONSTANT ;
terminal TOK_FLOAT ;
terminal TOK_STRING ;
terminal TOK_NUMBER ;
terminal TOK_COMMENT ;
/*
 * These are the predefined functions that can be accessed from Pike.
 */


terminal TOK_INC TOK_DEC ;
terminal TOK_RETURN ;
//terminal TOK_THROW;
//terminal TOK_GOTO;
terminal TOK_EQ ;
terminal TOK_GE ;
terminal TOK_LE ;
terminal TOK_NE ;
terminal TOK_NOT ;
terminal TOK_LSH ;
terminal TOK_RSH ;
terminal TOK_LAND ;
terminal TOK_LOR ;
terminal TOK_INC ;

terminal TOK_SWITCH ;
terminal TOK_SSCANF ;
terminal TOK_CATCH ;
terminal TOK_FOREACH ;

/* This is the end of file marker used by the lexer
 * to enable nicer EOF in error handling.
 */
terminal TOK_LEX_EOF ;

terminal TOK_ADD_EQ ;
terminal TOK_AND_EQ ; 
terminal TOK_ARRAY_ID ;
terminal TOK_BREAK ;
//terminal TOK_THIS;
terminal TOK_CASE ;
terminal TOK_CLASS ;
terminal TOK_COLON_COLON ;
terminal TOK_CONTINUE ;
terminal TOK_DEFAULT ;
terminal TOK_DIV_EQ ;
terminal TOK_DO ;
terminal TOK_DOT_DOT ;
terminal TOK_DOT_DOT_DOT ;
terminal TOK_ELSE ;
terminal TOK_ENUM ;
terminal TOK_EXTERN ;
terminal TOK_FLOAT_ID ;
terminal TOK_FOR ;
terminal TOK_FUNCTION_ID ;
terminal TOK_GAUGE ;
terminal TOK_GLOBAL ;
terminal TOK_IDENTIFIER ;
terminal TOK_IF ;
terminal TOK_IMPORT ;
terminal TOK_INHERIT ;
terminal TOK_INLINE ;
terminal TOK_LOCAL_ID ;
terminal TOK_FINAL_ID ;
terminal TOK_INT_ID ;
terminal TOK_LAMBDA ;
terminal TOK_MULTISET_ID ;
terminal TOK_MULTISET_END ;
terminal TOK_MULTISET_START ;
terminal TOK_LSH_EQ ;
terminal TOK_MAPPING_ID ;
terminal TOK_MIXED_ID ;
terminal TOK_MOD_EQ ;
terminal TOK_MULT_EQ ;
terminal TOK_NO_MASK ;
terminal TOK_OBJECT_ID ;
terminal TOK_OR_EQ ;
terminal TOK_PRIVATE ;
terminal TOK_PROGRAM_ID ;
terminal TOK_PROTECTED ;
terminal TOK_PREDEF ;
terminal TOK_PUBLIC ;
terminal TOK_RSH_EQ ;
terminal TOK_STATIC ;
terminal TOK_STRING_ID ;
terminal TOK_SUB_EQ ;
terminal TOK_TYPEDEF ;
terminal TOK_TYPEOF ;
terminal TOK_VARIANT ;
terminal TOK_VOID_ID ;
terminal TOK_WHILE ;
terminal TOK_XOR_EQ ;
terminal TOK_OPTIONAL ;

terminal LBRACK, RBRACK; // array_type
terminal DOT; // qualified_name
terminal SEMICOLON, MULT, COMMA, LBRACE, RBRACE, EQ, LPAREN, RPAREN, COLON;
terminal PLUS, MINUS, COMP, DIV, MOD;
terminal AT, GT, LT;
terminal AND; // and_expression
terminal XOR; // exclusive_or_expression
terminal OR;  // inclusive_or_expression
terminal QUESTION; // conditional_expression

non terminal goal;
non terminal program;
non terminal string_constant;
non terminal optional_rename_inherit;
non terminal low_program_ref;
non terminal program_ref;
non terminal inheritance;
non terminal _import;
non terminal constant_name;
non terminal constant_list;
non terminal constant;
non terminal block_or_semi;
non terminal type_or_error;
non terminal open_paren_with_line_info;
non terminal close_paren_or_missing;
non terminal close_brace_or_missing;
non terminal close_brace_or_eof;
non terminal open_bracket_with_line_info;
non terminal close_bracket_or_missing;
non terminal push_compiler_frame0;
non terminal def;
non terminal optional_dot_dot_dot;
non terminal optional_identifier;
non terminal new_arg_name;
non terminal func_args;
non terminal arguments;
non terminal arguments2;
non terminal magic_identifiers;
non terminal magic_identifier;
non terminal modifiers;
non terminal modifier_list;
non terminal optional_stars;
non terminal cast;
non terminal soft_cast;
non terminal full_type;
non terminal type6;
non terminal type;
non terminal type7;
non terminal simple_type;
non terminal simple_type2;
non terminal simple_identifier_type;
non terminal type4;
non terminal type2;
non terminal type8;
non terminal identifier_type;
non terminal number_or_maxint;
non terminal number_or_minint;
non terminal expected_dot_dot;
non terminal opt_int_range;
non terminal opt_object_type;
non terminal opt_function_type;
non terminal function_type_list;
non terminal function_type_list2;
non terminal opt_array_type;
non terminal opt_mapping_type;
non terminal name_list;
non terminal new_name;
non terminal new_local_name;
non terminal new_local_name2;
non terminal line_number_info;
non terminal end_block;
non terminal failsafe_block;
non terminal local_name_list;
non terminal local_name_list2;
non terminal local_constant_name;
non terminal local_constant_list;
non terminal local_constant;
non terminal statement_with_semicolon;
non terminal normal_label_statement;
non terminal statement;
non terminal labeled_statement;
non terminal optional_label;
non terminal break;
non terminal default;
non terminal continue;
non terminal push_compiler_frame1;
non terminal lambda;
non terminal local_function;
non terminal local_function2;
non terminal create_arg;
non terminal create_arguments2;
non terminal create_arguments;
non terminal push_compiler_frame01;
non terminal optional_create_arguments;
non terminal failsafe_program;
non terminal class;
non terminal simple_identifier;
non terminal enum_value;
non terminal enum_def;
non terminal enum_list;
non terminal enum;
non terminal typedef;
non terminal cond;
non terminal end_cond;
non terminal optional_else_part;
non terminal safe_lvalue;
non terminal safe_expr0;
non terminal foreach_optional_lvalue;
non terminal foreach_lvalues;
non terminal foreach;
non terminal do;
non terminal expected_semicolon;
non terminal for;
non terminal while;
non terminal for_expr;
non terminal case;
non terminal expected_colon;
non terminal return;
non terminal unused2;
non terminal optional_comma_expr;
non terminal safe_comma_expr;
non terminal comma_expr;
non terminal comma_expr2;
non terminal expr00;
non terminal expr0;
non terminal expr01;
non terminal assign;
non terminal optional_comma;
non terminal expr_list2;
non terminal m_expr_list;
non terminal m_expr_list2;
non terminal assoc_pair;
non terminal expr1;
non terminal expr2;
non terminal expr3;
non terminal optional_block;
non terminal expr4;
non terminal idents2;
non terminal idents;
non terminal inherit_specifier;
non terminal low_idents;
non terminal comma_expr_or_zero;
non terminal comma_expr_or_maxint;
non terminal gauge;
non terminal typeof;
non terminal catch_arg;
non terminal catch;
non terminal sscanf;
non terminal lvalue;
non terminal low_lvalue_list;
non terminal lvalue_list;
non terminal string;
non terminal bad_identifier;
non terminal inherit_ref;
non terminal modifier;
non terminal magic_identifiers1;
non terminal magic_identifiers2;
non terminal magic_identifiers3;
non terminal basic_type;
non terminal block;
non terminal statements;
non terminal switch;
non terminal unused;
non terminal expr_list;
non terminal bad_expr_ident;


precedence right EQ ;
precedence right QUESTION ;
precedence left TOK_LOR ;
precedence left TOK_LAND ;
precedence left OR ;
precedence left XOR ;
precedence left AND ;
precedence left TOK_EQ, TOK_NE ;
precedence left GT, TOK_GE, LT, TOK_LE ;  /* nonassoc? */
precedence left TOK_LSH, TOK_RSH ;
precedence left PLUS, MINUS ;
precedence left MULT, MOD, DIV ;
precedence right TOK_NOT, COMP ;
precedence nonassoc TOK_INC, TOK_DEC ;


goal::= program 
  | program TOK_LEX_EOF

  ;

program::= program def
  | program SEMICOLON
  |  /* empty */
  ;

string_constant::= string
  | string_constant PLUS string
  ;

optional_rename_inherit::= COLON TOK_IDENTIFIER:ident {: RESULT = ident; :}
  | COLON bad_identifier 
  | COLON error 
  | 
  ;

/* NOTE: This rule pushes a string "name" on the stack in addition
 * to resolving the program reference.
 */
low_program_ref::= string_constant:constant {: RESULT = constant; System.out.println("have constant."); :}
  | idents:idents {: RESULT = idents; :}
  ;

/* NOTE: Pushes the resolved program on the stack. */
program_ref::= low_program_ref
  ;

inherit_ref::=
  low_program_ref:ref {: RESULT = ref; :}
  ;

inheritance::= modifiers TOK_INHERIT inherit_ref:ref optional_rename_inherit:name SEMICOLON {: parser.source.addInherit(new InheritItem((PikeSymbol)ref, (PikeSymbol)name, parser.source.currentModifiers)); parser.source.currentModifiers = 0; :}
  | modifiers TOK_INHERIT inherit_ref error SEMICOLON {: parser.source.currentModifiers = 0; :}
  | modifiers TOK_INHERIT inherit_ref error TOK_LEX_EOF {: parser.source.currentModifiers = 0; :}
  | modifiers TOK_INHERIT inherit_ref error RBRACE {: parser.source.currentModifiers = 0; :}
  | modifiers TOK_INHERIT error SEMICOLON {: parser.source.currentModifiers = 0; :}
  | modifiers TOK_INHERIT error TOK_LEX_EOF {: parser.source.currentModifiers = 0; :}
  | modifiers TOK_INHERIT error RBRACE  {: parser.source.currentModifiers = 0; :}
  ;

_import::= TOK_IMPORT idents SEMICOLON
  | TOK_IMPORT string SEMICOLON
  | TOK_IMPORT error SEMICOLON
  | TOK_IMPORT error TOK_LEX_EOF
  | TOK_IMPORT error RBRACE {: parser.yyerror("Missing SEMICOLON."); :}
  ;

constant_name::= TOK_IDENTIFIER:ident EQ safe_expr0 {: RESULT = (PikeSymbol)ident; :}
  | bad_identifier EQ safe_expr0
  | error EQ safe_expr0
  ;

constant_list::= constant_name:name {: RESULT = new ConstantList((PikeSymbol)name); :}
  | constant_list:constantlist COMMA constant_name:name1 {: RESULT = ((ConstantList)constantlist); ((ConstantList)constantlist).add((PikeSymbol)name1); :}
  ;

constant::= modifiers TOK_CONSTANT constant_list:list SEMICOLON {: parser.source.addConstants((ConstantList)list, parser.source.currentModifiers); parser.source.currentModifiers = 0;:}
  | modifiers TOK_CONSTANT error SEMICOLON {: parser.source.currentModifiers = 0; :}
  | modifiers TOK_CONSTANT error TOK_LEX_EOF {: parser.source.currentModifiers = 0; :} 
  | modifiers TOK_CONSTANT error RBRACE {: parser.source.currentModifiers = 0; parser.yyerror("Missing ';'."); :}
  ;

block_or_semi::= block:block {: RESULT = block; :}
  | SEMICOLON
  | TOK_LEX_EOF {:  parser.yyerror("Expected ';'."); :}
  | error
  ;


type_or_error::= simple_type
  ;

open_paren_with_line_info::= LPAREN
  ;

close_paren_or_missing::= RPAREN
  | /* empty */
  ;

close_brace_or_missing::= RBRACE
  | /* empty */
  {:
    parser.yyerror("Missing ']'.");
  :}
  ;

close_brace_or_eof::= RBRACE
  | TOK_LEX_EOF
  {:
    parser.yyerror("Missing '['.");
  :}
  ;

open_bracket_with_line_info::= LBRACK
  ;

close_bracket_or_missing::= RBRACK
  | /* empty */
  {:
    parser.yyerror("Missing ']'.");
  :}
  ;

push_compiler_frame0::= /* empty */
  {:
   :}
  ;

def::= modifiers type_or_error optional_stars TOK_IDENTIFIER:ident push_compiler_frame0
  LPAREN arguments close_paren_or_missing
  block_or_semi:block
  
      {: 
          if(block != null)
          {
            Block rblock = (Block)block;
            parser.source.addMethod((PikeSymbol)ident, (PikeSymbol)ident, rblock.start, rblock.end); 
          }
          else
          { /* a function declaraion */
          	System.out.println("whee! " + ((PikeSymbol)ident).getText());
          }
          parser.source.currentModifiers = 0;
      :}
/*
  | modifiers type_or_error optional_stars TOK_IDENTIFIER:ident push_compiler_frame0
	error   {: System.out.println("VAR"); :} 
*/
  | modifiers type_or_error optional_stars bad_identifier:ident
    LPAREN arguments RPAREN block_or_semi:block
    {:     
         if(block != null)
          {
            Block rblock = (Block)block;
            parser.source.addMethod((PikeSymbol)ident, (PikeSymbol)ident, rblock.start, rblock.end); 
//            System.out.println("have function: " + ident.toString() + " " + (block!=null?block.toString():"null")); 
          }
          else
          { /* a function declaraion */
          	System.out.println("whee! " + ((PikeSymbol)ident).getText());
          }
          parser.source.currentModifiers = 0;
    :}
  | modifiers type_or_error name_list:list SEMICOLON {: parser.source.addVariables((ArrayList)list); System.out.println("var: "); parser.source.currentModifiers = 0; :}
  | inheritance {: :}
  | _import {: :}
  | constant {: :}
  | class {: :}
  | enum {: :}
  | typedef {: :}
  | error TOK_LEX_EOF
  {:
    parser.yyerror("Missing ';'.");
    parser.yyerror("Unexpected end of file");
  :}
  | error SEMICOLON
  | error RBRACE
  {:
    parser.yyerror("Missing ';'.");
  :}
  | modifiers
   LBRACE 
      program
   close_brace_or_eof {: parser.source.currentModifiers = 0; :}
  ;

optional_dot_dot_dot::= TOK_DOT_DOT_DOT
  | TOK_DOT_DOT
  {:
    parser.yyerror("Range indicator ('..') where elipsis ('...') expected.");
  :}
  | /* empty */
  ;

optional_identifier::= TOK_IDENTIFIER:ident {: RESULT = ident; :}
  | bad_identifier
  | /* empty */
  ;

new_arg_name::= type7 optional_dot_dot_dot optional_identifier
  ;

func_args::= LPAREN arguments close_paren_or_missing
  ;

arguments::= /* empty */ optional_comma 
  | arguments2 optional_comma
  ;

arguments2::= new_arg_name 
  | arguments2 COMMA new_arg_name 
  | arguments2 COLON new_arg_name
  {:
    parser.yyerror("Unexpected ':' in argument list.");
  :}
  ;

modifier::=
    TOK_NO_MASK    
  | TOK_FINAL_ID   
  | TOK_STATIC {: parser.source.currentModifiers |= 4; :}
  | TOK_EXTERN     
  | TOK_OPTIONAL   
  | TOK_PRIVATE {: parser.source.currentModifiers |= 2; :}   
  | TOK_LOCAL_ID   
  | TOK_PUBLIC    {: parser.source.currentModifiers = 0; :} 
  | TOK_PROTECTED  
  | TOK_INLINE     
  | TOK_VARIANT    
  ;

magic_identifiers1::=
    TOK_NO_MASK    
  | TOK_FINAL_ID   
  | TOK_STATIC     
  | TOK_EXTERN	  
  | TOK_PRIVATE    
  | TOK_LOCAL_ID   
  | TOK_PUBLIC     
  | TOK_PROTECTED  
  | TOK_INLINE     
  | TOK_OPTIONAL   
  | TOK_VARIANT    
  ;

magic_identifiers2::=
    TOK_VOID_ID       
  | TOK_MIXED_ID      
  | TOK_ARRAY_ID      
  | TOK_MAPPING_ID    
  | TOK_MULTISET_ID   
  | TOK_OBJECT_ID     
  | TOK_FUNCTION_ID   
  | TOK_PROGRAM_ID    
  | TOK_STRING_ID     
  | TOK_FLOAT_ID      
  | TOK_INT_ID        
  | TOK_ENUM	      
  | TOK_TYPEDEF       
  ;

magic_identifiers3::=
    TOK_IF         
  | TOK_DO         
  | TOK_FOR        
  | TOK_WHILE      
  | TOK_ELSE       
  | TOK_FOREACH    
  | TOK_CATCH      
  | TOK_GAUGE      
  | TOK_CLASS      
  | TOK_BREAK      
  | TOK_CASE       
  | TOK_CONSTANT   
  | TOK_CONTINUE   
  | TOK_DEFAULT    
  | TOK_IMPORT     
  | TOK_INHERIT    
  | TOK_LAMBDA     
  | TOK_PREDEF     
  | TOK_RETURN     
  | TOK_SSCANF     
  | TOK_SWITCH     
  | TOK_TYPEOF     
  | TOK_GLOBAL     
  ;

magic_identifiers::= magic_identifiers1 | magic_identifiers2 | magic_identifiers3 ;

magic_identifier::= TOK_IDENTIFIER 
  | magic_identifiers
  ;

modifiers::= modifier_list
 ;

modifier_list::= /* empty */ 
  | modifier:modifier modifier_list {: // System.out.println("modifier: " + parser.source.currentModifiers);
     parser.source.currentModifiers = 0 ; 
   :}
  ;

optional_stars::= optional_stars MULT 
  | /* empty */
  ;

cast::= open_paren_with_line_info type RPAREN
    ;

soft_cast::= open_bracket_with_line_info type RBRACK
    ;

full_type::= type4
  | full_type MULT
  ;

type6::= type | identifier_type ;
  
type::= type MULT
  | type2
  ;

type7::= type7 MULT
  | type4
  ;

simple_type::= type4
  ;

simple_type2::= type2
  ;

simple_identifier_type::= identifier_type
  ;

type4::= type4 OR type8 
  | type8
  ;

type2::= type2 OR type8
  | basic_type 
  ;

type8::= basic_type | identifier_type ;

basic_type::=
    TOK_FLOAT_ID                      
  | TOK_VOID_ID                       
  | TOK_MIXED_ID                      
  | TOK_STRING_ID                     
  | TOK_INT_ID      opt_int_range     
  | TOK_MAPPING_ID  opt_mapping_type  
  | TOK_FUNCTION_ID opt_function_type 
  | TOK_OBJECT_ID   opt_object_type   
  | TOK_PROGRAM_ID  opt_object_type   
  | TOK_ARRAY_ID    opt_array_type    
  | TOK_MULTISET_ID opt_array_type    
  ;

identifier_type::= idents
  ;

number_or_maxint::= /* Empty */
  | TOK_NUMBER
  | MINUS TOK_NUMBER
  ;

number_or_minint::= /* Empty */
  | TOK_NUMBER
  | MINUS TOK_NUMBER
  ;

expected_dot_dot::= TOK_DOT_DOT
  | TOK_DOT_DOT_DOT
  {:
    parser.yyerror("Elipsis ('...') where range indicator ('..') expected.");
  :}
  ;

opt_int_range::= /* Empty */
  | LPAREN number_or_minint expected_dot_dot number_or_maxint RPAREN
  ;

opt_object_type::=  /* Empty */ 
  |
    LPAREN program_ref RPAREN
  ;

opt_function_type::= LPAREN
  function_type_list optional_dot_dot_dot COLON
  type7 RPAREN
  | /* empty */
  ;

function_type_list::= /* Empty */ optional_comma 
  | function_type_list2 optional_comma 
  ;

function_type_list2::= type7 
  | function_type_list2 COMMA
  type7
  ;

opt_array_type::= LPAREN type7 RPAREN
  |  
  ;

opt_mapping_type::= LPAREN
  type7 COLON
  type7
  RPAREN
  | /* empty */ 
  ;



name_list::= new_name:name {: ArrayList l = new ArrayList(); l.add(name); RESULT = l; :}
  | name_list:list COMMA new_name:name {: ((ArrayList)list).add(name); RESULT = list; :}
  ;

new_name::= optional_stars TOK_IDENTIFIER:ident {: RESULT = ident; :}
  | optional_stars bad_identifier:ident {: RESULT = ident; :}
  | optional_stars TOK_IDENTIFIER:ident EQ
  expr0 {: RESULT = ident; :}
  | optional_stars TOK_IDENTIFIER EQ error
  | optional_stars TOK_IDENTIFIER EQ TOK_LEX_EOF
  {:
    parser.yyerror("Unexpected end of file in variable definition.");
  :}
  | optional_stars bad_identifier:ident EQ expr0 {: RESULT = ident; :}
  ;


new_local_name::= optional_stars TOK_IDENTIFIER
  | optional_stars bad_identifier
  | optional_stars TOK_IDENTIFIER EQ expr0 
  | optional_stars bad_identifier EQ expr0
  | optional_stars TOK_IDENTIFIER EQ error
  | optional_stars TOK_IDENTIFIER EQ TOK_LEX_EOF
  {:
    parser.yyerror("Unexpected end of file in local variable definition.");
  :}
  ;

new_local_name2::= TOK_IDENTIFIER
  | bad_identifier
  | TOK_IDENTIFIER EQ safe_expr0
  | bad_identifier EQ safe_expr0
  ;

line_number_info::= /* empty */
  ;

block::= LBRACE:start
  line_number_info
  statements end_block:end
  {: RESULT = new Block((CurlySymbol)start, (CurlySymbol)end); :}
  ;

end_block::= RBRACE:end {: RESULT = end; :}
  | TOK_LEX_EOF
  {:
    parser.yyerror("Missing '}'.");
    parser.yyerror("Unexpected end of file.");
  :}
  ;

failsafe_block::= block
              | error 
              | TOK_LEX_EOF {: parser.yyerror("Unexpected end of file."); :}
              ;


local_name_list::= new_local_name
  | local_name_list COMMA new_local_name
  ;

local_name_list2::= new_local_name2
  | local_name_list2 COMMA {: :} new_local_name
  ;


local_constant_name::= TOK_IDENTIFIER EQ safe_expr0
  | bad_identifier EQ safe_expr0
  | error EQ safe_expr0
  ;

local_constant_list::= local_constant_name
  | local_constant_list COMMA local_constant_name
  ;

local_constant::= TOK_CONSTANT local_constant_list SEMICOLON
  | TOK_CONSTANT error SEMICOLON
  | TOK_CONSTANT error TOK_LEX_EOF
  {:
    parser.yyerror("Missing SEMICOLON.");
    parser.yyerror("Unexpected end of file.");
  :}
  | TOK_CONSTANT error RBRACE {: parser.yyerror("Missing ';'."); :}
  ;


statements::=
  | statements statement
  ;

statement_with_semicolon::= unused2 optional_block
;

normal_label_statement::= statement_with_semicolon
  | _import
  | cond
  | return
  | local_constant
  | block
  | break expected_semicolon
  | continue expected_semicolon
  | error SEMICOLON
  | error TOK_LEX_EOF
  {:
    parser.yyerror("Missing ';'.");
    parser.yyerror("Unexpected end of file.");
  :}
  | error RBRACE
  {:
    parser.yyerror("Missing ';'.");
  :}
  | SEMICOLON
  ;

statement::= normal_label_statement
  | while
  | do
  | for
  | foreach
  | switch
  | case
  | default
  | labeled_statement
  ;

labeled_statement::= TOK_IDENTIFIER
  COLON statement
  ;

optional_label::= TOK_IDENTIFIER
  | /* empty */ 
  ;

break::= TOK_BREAK optional_label  ;
default::= TOK_DEFAULT COLON 
  | TOK_DEFAULT
  {:
    parser.yyerror("Expected ':' after default.");
  :}
  ;

continue::= TOK_CONTINUE optional_label ;

push_compiler_frame1::= /* empty */
  ;

lambda::= TOK_LAMBDA line_number_info push_compiler_frame1
  func_args
  failsafe_block
  | TOK_LAMBDA line_number_info push_compiler_frame1 error
  ;

local_function::= TOK_IDENTIFIER push_compiler_frame1 func_args 
  failsafe_block
  | TOK_IDENTIFIER push_compiler_frame1 error
  ;

local_function2::= optional_stars TOK_IDENTIFIER push_compiler_frame1 func_args 
  failsafe_block
  | optional_stars TOK_IDENTIFIER push_compiler_frame1 error
  ;

create_arg::= modifiers type_or_error optional_stars optional_dot_dot_dot TOK_IDENTIFIER:ident   {: RESULT=ident; parser.source.currentModifiers = 0 ; :}
  | modifiers type_or_error optional_stars bad_identifier   {: parser.source.currentModifiers = 0 ; :}
  ;

create_arguments2::= create_arg:ident {: ArrayList list = new ArrayList(); list.add(ident); RESULT = list; :}
  | create_arguments2:list COMMA create_arg:ident {: ((ArrayList)list).add(ident); RESULT = list; :}
  | create_arguments2 COLON create_arg
  {:
    parser.yyerror("Unexpected ':' in create argument list.");
  :}
  ;

create_arguments::= /* empty */ optional_comma
  | create_arguments2:list optional_comma {: RESULT = list; :}
  ;

push_compiler_frame01::= /* empty */
  ;

optional_create_arguments::= /* empty */ 
  | LPAREN push_compiler_frame01 create_arguments:ident {: RESULT = ident; :} close_paren_or_missing
  ;

failsafe_program::= LBRACE program end_block:end {: RESULT = end; :}
                | error 
                | TOK_LEX_EOF
                {:
		  parser.yyerror("End of file where program definition expected.");
		:}
                ;

class::= modifiers:modifiers TOK_CLASS line_number_info optional_identifier:identifier {: System.out.println("identifier:" + (identifier!=null?((PikeSymbol)identifier).value:"null")); if(identifier != null)  parser.source.addClass((PikeSymbol)identifier, parser.source.currentModifiers); else parser.source.addClass("(anonymous)"); parser.source.currentModifiers = 0 ; :}
  optional_create_arguments:args {: parser.source.addVariables((ArrayList)args); :} failsafe_program:prog
  {: parser.source.endClass((PikeSymbol)prog); :}
  ;

simple_identifier::= TOK_IDENTIFIER
  | bad_identifier 
  ;

enum_value::= /* EMPTY */
  | EQ safe_expr0
  ;

enum_def::= /* EMPTY */
  | simple_identifier enum_value
  ;

enum_list::= enum_def
  | enum_list COMMA enum_def
  ;

enum::= modifiers TOK_ENUM
  optional_identifier LBRACE enum_list end_block
  ;

typedef::= modifiers TOK_TYPEDEF full_type simple_identifier SEMICOLON
  ;

cond::= TOK_IF
  line_number_info
  LPAREN safe_comma_expr end_cond statement optional_else_part
  ;

end_cond::= RPAREN
  | RBRACE {: parser.yyerror("Missing ')'."); :}
  | TOK_LEX_EOF
  {:
    parser.yyerror("Missing ')'.");
    parser.yyerror("Unexpected end of file.");
  :}
  ;

optional_else_part::= 
  | TOK_ELSE statement 
  ;      

safe_lvalue::= lvalue
  | error 
  ;

safe_expr0::= expr0
  | TOK_LEX_EOF {: parser.yyerror("Unexpected end of file.");  :}
  | error 
  ;


foreach_optional_lvalue::= /* empty */ 
   | safe_lvalue
   ;

foreach_lvalues::=  COMMA safe_lvalue 
  | SEMICOLON foreach_optional_lvalue SEMICOLON foreach_optional_lvalue
  ;

foreach::= TOK_FOREACH
  line_number_info
  LPAREN expr0 foreach_lvalues end_cond statement
  ;

do::= TOK_DO line_number_info statement
  TOK_WHILE LPAREN safe_comma_expr end_cond expected_semicolon
  | TOK_DO line_number_info statement TOK_WHILE TOK_LEX_EOF
  {:
    parser.yyerror("Missing '(' in do-while loop.");
    parser.yyerror("Unexpected end of file.");
  :}
  | TOK_DO line_number_info statement TOK_LEX_EOF
  {:
    parser.yyerror("Missing 'while' in do-while loop.");
    parser.yyerror("Unexpected end of file.");
  :}
  ;

expected_semicolon::= SEMICOLON
  | TOK_LEX_EOF
  {:
    parser.yyerror("Missing ';'.");
    parser.yyerror("Unexpected end of file.");
  :}
  ;

for::= TOK_FOR
  line_number_info
  LPAREN unused expected_semicolon for_expr expected_semicolon unused end_cond
  statement
  ;


while::=  TOK_WHILE
  line_number_info
  LPAREN safe_comma_expr end_cond statement
  ;

for_expr::= /* EMPTY */ 
  | safe_comma_expr
  ;

switch::=	TOK_SWITCH
  line_number_info
  LPAREN safe_comma_expr end_cond statement
  ;

case::= TOK_CASE safe_comma_expr expected_colon
  | TOK_CASE safe_comma_expr expected_dot_dot optional_comma_expr expected_colon
  | TOK_CASE expected_dot_dot safe_comma_expr expected_colon
  ;

expected_colon::= COLON
  | SEMICOLON
  {:
    parser.yyerror("Missing ':'.");
  :}
  | RBRACE
  {:
    parser.yyerror("Missing ':'.");
  :}
  | TOK_LEX_EOF
  {:
    parser.yyerror("Missing ':'.");
    parser.yyerror("Unexpected end of file.");
  :}
  ;

return::= TOK_RETURN expected_semicolon
  | TOK_RETURN safe_comma_expr expected_semicolon
  ;
	
unused::=
  | safe_comma_expr
  ;

unused2::= comma_expr ;

optional_comma_expr::= 
  | safe_comma_expr
  ;

safe_comma_expr::= comma_expr
  | error 
  ;

comma_expr::= comma_expr2
  | simple_type2 local_name_list 
  | simple_identifier_type local_name_list2 
  | simple_identifier_type local_function 
  | simple_type2 local_function2 
  ;
          

comma_expr2::= expr0
  | comma_expr2 COMMA expr0
  ;

expr00::= expr0
      | AT expr0 ;

expr0::= expr01
  | expr4 EQ expr0  
  | expr4 EQ error
  | bad_expr_ident EQ expr0 
  | open_bracket_with_line_info low_lvalue_list RBRACK EQ expr0
  | expr4 assign expr0  
  | expr4 assign error 
  | bad_expr_ident assign expr0
  | open_bracket_with_line_info low_lvalue_list RBRACK assign expr0
  | open_bracket_with_line_info low_lvalue_list RBRACK error
    {:  :}
/*  | error {: $$=0; reset_type_stack(); :} */
  ;

expr01::= expr1
  | expr1 QUESTION expr01 COLON expr01 
  ;

assign::= TOK_AND_EQ 
  | TOK_OR_EQ  
  | TOK_XOR_EQ 
  | TOK_LSH_EQ 
  | TOK_RSH_EQ 
  | TOK_ADD_EQ 
  | TOK_SUB_EQ 
  | TOK_MULT_EQ
  | TOK_MOD_EQ 
  | TOK_DIV_EQ 
  ;

optional_comma::=  | COMMA ;

expr_list::=
  | expr_list2 optional_comma
  ;
         

expr_list2::= expr00
  | expr_list2 COMMA expr00 
  ;

m_expr_list::= 
  | m_expr_list2 optional_comma
  ;

m_expr_list2::= assoc_pair
  | m_expr_list2 COMMA assoc_pair
  | m_expr_list2 COMMA error
  ;

assoc_pair::=  expr0 expected_colon expr0 
  | expr0 expected_colon error
  ;

expr1::= expr2
  | expr1 TOK_LOR expr1  
  | expr1 TOK_LAND expr1 
  | expr1 OR expr1    
  | expr1 XOR expr1    
  | expr1 AND expr1    
  | expr1 TOK_EQ expr1   
  | expr1 TOK_NE expr1   
  | expr1 GT expr1    
  | expr1 TOK_GE expr1   
  | expr1 LT expr1    
  | expr1 TOK_LE expr1   
  | expr1 TOK_LSH expr1  
  | expr1 TOK_RSH expr1  
  | expr1 PLUS expr1    
  | expr1 MINUS expr1    
  | expr1 MULT expr1    
  | expr1 MOD expr1    
  | expr1 DIV expr1    
  | expr1 TOK_LOR error 
  | expr1 TOK_LAND error
  | expr1 OR error   
  | expr1 XOR error   
  | expr1 AND error   
  | expr1 TOK_EQ error  
  | expr1 TOK_NE error  
  | expr1 GT error   
  | expr1 TOK_GE error  
  | expr1 LT error   
  | expr1 TOK_LE error  
  | expr1 TOK_LSH error 
  | expr1 TOK_RSH error 
  | expr1 PLUS error   
  | expr1 MINUS error   
  | expr1 MULT error   
  | expr1 MOD error   
  | expr1 DIV error
  ;

expr2::= expr3
  | cast expr2
  | soft_cast expr2
  | TOK_INC expr4      
  | TOK_DEC expr4      
  | TOK_NOT expr2        
  | COMP expr2          
  | MINUS expr2          
  ;

expr3::= expr4
  | expr4 TOK_INC       
  | expr4 TOK_DEC      
  ;

/* FIXMEs
 * It would be nice if 'return' would exit from
 * the surrounding function rather than from the
 * implicit lambda. (I think) So beware that the
 * behaviour of 'return' might change some day.
 * -Hubbe
 *
 * It would also be nice if it was possible to send
 * arguments to the implicit function, but it would
 * require using ugly implicit variables or extending
 * the syntax, and if you extend the syntax you might
 * as well use lambda() instead.
 * -Hubbe
 *
 * We might want to allow having more than block after
 * a function ( ie. func(args) {::} {::} {::} {::} )
 * -Hubbe
 */

optional_block::= SEMICOLON /* EMPTY */ {:  :}
  | LBRACE line_number_info push_compiler_frame0
  statements end_block expected_semicolon
  ;

expr4::= string
  | TOK_NUMBER 
  | TOK_FLOAT
  | catch
  | gauge
  | typeof
  | sscanf
  | lambda
  | class
  | enum
  | idents2
  | expr4 open_paren_with_line_info expr_list  RPAREN
  | expr4 open_paren_with_line_info error RPAREN
  | expr4 open_paren_with_line_info error TOK_LEX_EOF
  {:
    parser.yyerror("Missing ')'.");
    parser.yyerror("Unexpected end of file.");
  :}
  | expr4 open_paren_with_line_info error SEMICOLON
  {:
    parser.yyerror("Missing ')'.");
  :}
  | expr4 open_paren_with_line_info error RBRACE
  {:
    parser.yyerror("Missing ')'.");
  :}
  | expr4 open_bracket_with_line_info MULT RBRACK
  | expr4 open_bracket_with_line_info expr0 RBRACK
  | expr4 open_bracket_with_line_info
    comma_expr_or_zero expected_dot_dot comma_expr_or_maxint RBRACK
  | expr4 open_bracket_with_line_info error RBRACK
  | expr4 open_bracket_with_line_info error TOK_LEX_EOF
  {:
    parser.yyerror("Missing ']'.");
    parser.yyerror("Unexpected end of file.");
  :}
  | expr4 open_bracket_with_line_info error SEMICOLON
    {: parser.yyerror("Missing ']'."); :}
  | expr4 open_bracket_with_line_info error RBRACE
    {: parser.yyerror("Missing ']'."); :}
  | expr4 open_bracket_with_line_info error RPAREN
    {: parser.yyerror("Missing ']'."); :}
  | open_paren_with_line_info comma_expr2 RPAREN
  | open_paren_with_line_info LBRACE:lcurly expr_list close_brace_or_missing RPAREN:rcurly {: System.out.println("array! "+ lcurly + "\n"); :}
  | open_paren_with_line_info
    open_bracket_with_line_info	/* Only to avoid shift/reduce conflicts. */
    m_expr_list close_bracket_or_missing RPAREN
  | TOK_MULTISET_START line_number_info expr_list TOK_MULTISET_END
  | TOK_MULTISET_START line_number_info expr_list RPAREN:e
    {:
      parser.yyerror("Missing '>'.");
    :}
  | open_paren_with_line_info error RPAREN
  | open_paren_with_line_info error TOK_LEX_EOF
  {:
    parser.yyerror("Missing ')'.");
    parser.yyerror("Unexpected end of file.");
  :}
  | open_paren_with_line_info error SEMICOLON {: parser.yyerror("Missing ')'."); :}
  | open_paren_with_line_info error RBRACE {: parser.yyerror("Missing ')'."); :}
  | TOK_MULTISET_START line_number_info error TOK_MULTISET_END 
  | TOK_MULTISET_START line_number_info error RPAREN {:
    parser.yyerror("Missing '>'.");
  :}
  | TOK_MULTISET_START line_number_info error TOK_LEX_EOF
  {:
    parser.yyerror("Missing '>)'.");
    parser.yyerror("Unexpected end of file.");
  :}
  | TOK_MULTISET_START line_number_info error SEMICOLON {: parser.yyerror("Missing '>)'."); :}
  | TOK_MULTISET_START line_number_info error RBRACE {: parser.yyerror("Missing '>)'."); :}
  | expr4 TOK_ARROW line_number_info magic_identifier
  | expr4 TOK_ARROW line_number_info error 
  ;

idents2::= idents
  | TOK_LOCAL_ID TOK_COLON_COLON TOK_IDENTIFIER
  | TOK_LOCAL_ID TOK_COLON_COLON bad_identifier
  ;

idents::= low_idents:idents {: RESULT = idents; :}
  | idents:idents DOT TOK_IDENTIFIER:ident {: RESULT = new PikeSymbol(sym.TOK_IDENTIFIER, ((PikeSymbol)idents).getLine(), ((PikeSymbol)idents).getColumn(), identsleft, identright, ((PikeSymbol)idents).getOffset(), ((PikeSymbol)idents).getText() + "." + ((PikeSymbol)ident).getText()); :}
  | DOT:dot TOK_IDENTIFIER:ident {: RESULT = new PikeSymbol(sym.TOK_IDENTIFIER, ((PikeSymbol)dot).getLine(), ((PikeSymbol)dot).getColumn(), dotleft, identright, ((PikeSymbol)dot).getOffset(), "." + ((PikeSymbol)ident).getText()); :}
  | TOK_GLOBAL:global DOT TOK_IDENTIFIER:ident {: RESULT = new PikeSymbol(sym.TOK_IDENTIFIER, ((PikeSymbol)global).getLine(), ((PikeSymbol)global).getColumn(), globalleft, identright, ((PikeSymbol)global).getOffset(), "global." + ((PikeSymbol)ident).getText()); :}
  | idents DOT bad_identifier {::}
  | idents DOT error {::}
  ;

inherit_specifier::= TOK_IDENTIFIER:ident TOK_COLON_COLON:tok {: RESULT = new PikeSymbol(sym.TOK_IDENTIFIER, ((PikeSymbol)ident).getLine(), ((PikeSymbol)ident).getColumn(), identleft, tokright, ((PikeSymbol)ident).getOffset(), ((PikeSymbol)ident).getText() + ((PikeSymbol)tok).getText()); :}
  | TOK_GLOBAL:ident TOK_COLON_COLON:tok {: RESULT = new PikeSymbol(sym.TOK_IDENTIFIER, ((PikeSymbol)ident).getLine(), ((PikeSymbol)ident).getColumn(), identleft, tokright, ((PikeSymbol)ident).getOffset(), ((PikeSymbol)ident).getText() + ((PikeSymbol)tok).getText()); :}
  | inherit_specifier:ident TOK_IDENTIFIER:tok1 TOK_COLON_COLON:tok {: RESULT = new PikeSymbol(sym.TOK_IDENTIFIER, ((PikeSymbol)ident).getLine(), ((PikeSymbol)ident).getColumn(), identleft, tokright, ((PikeSymbol)ident).getOffset(), ((PikeSymbol)ident).getText() + ((PikeSymbol)tok1).getText() + ((PikeSymbol)tok).getText()); :}
  | inherit_specifier bad_identifier TOK_COLON_COLON 
  ;

low_idents::= TOK_IDENTIFIER:ident {: RESULT = ident;  :}
  | TOK_PREDEF:predef TOK_COLON_COLON TOK_IDENTIFIER:ident {: RESULT = new PikeSymbol(sym.TOK_IDENTIFIER, ((PikeSymbol)predef).getLine(), ((PikeSymbol)predef).getColumn(), predefleft, identright, ((PikeSymbol)predef).getOffset(), ((PikeSymbol)predef).getText() + "::" + ((PikeSymbol)ident).getText()); :}
  | TOK_PREDEF TOK_COLON_COLON bad_identifier
  | inherit_specifier:spec TOK_IDENTIFIER:ident {: RESULT = new PikeSymbol(sym.TOK_IDENTIFIER, ((PikeSymbol)spec).getLine(), ((PikeSymbol)spec).getColumn(), specleft, identright, ((PikeSymbol)spec).getOffset(), ((PikeSymbol)spec).getText() + ((PikeSymbol)ident).getText()); :}
  | inherit_specifier bad_identifier 
  | inherit_specifier error 
  | TOK_COLON_COLON:tok TOK_IDENTIFIER:ident {: RESULT = new PikeSymbol(sym.TOK_IDENTIFIER, ((PikeSymbol)tok).getLine(), ((PikeSymbol)tok).getColumn(), tokleft, identright,((PikeSymbol)tok).getOffset(), ((PikeSymbol)tok).getText() + ((PikeSymbol)ident).getText()); :}
  | TOK_COLON_COLON bad_identifier
  ;

comma_expr_or_zero::= /* empty */ 
  | comma_expr
  | TOK_LEX_EOF {: parser.yyerror("Unexpected end of file."); :}
  ;

comma_expr_or_maxint::= /* empty */ 
  | comma_expr
  | TOK_LEX_EOF {: parser.yyerror("Unexpected end of file.");  :}
  ;

gauge::= TOK_GAUGE catch_arg
  ;

typeof::= TOK_TYPEOF LPAREN expr0 RPAREN
  | TOK_TYPEOF LPAREN error RPAREN {:  :}
  | TOK_TYPEOF LPAREN error RBRACE {: parser.yyerror("Missing ')'."); :}
  | TOK_TYPEOF LPAREN error TOK_LEX_EOF
  {:
    parser.yyerror("Missing ')'.");
    parser.yyerror("Unexpected end of file.");
  :}
  | TOK_TYPEOF LPAREN error SEMICOLON {:  parser.yyerror("Missing ')'."); :}
  ;
 
catch_arg::= LPAREN comma_expr RPAREN  
  | LPAREN error RPAREN 
  | LPAREN error TOK_LEX_EOF
  {:
    parser.yyerror("Missing ')'.");
    parser.yyerror("Unexpected end of file.");
  :}
  | LPAREN error RBRACE {: parser.yyerror("Missing ')'."); :}
  | LPAREN error SEMICOLON {: parser.yyerror("Missing ')'."); :}
  | block
  | error {: parser.yyerror("Bad expression for catch."); :}
  ; 

catch::= TOK_CATCH
     catch_arg
     ;

sscanf::= TOK_SSCANF LPAREN expr0 COMMA expr0 lvalue_list RPAREN
  | TOK_SSCANF LPAREN expr0 COMMA expr0 error RPAREN
  | TOK_SSCANF LPAREN expr0 COMMA expr0 error TOK_LEX_EOF
  {:
    parser.yyerror("Missing ')'.");
    parser.yyerror("Unexpected end of file.");
  :}
  | TOK_SSCANF LPAREN expr0 COMMA expr0 error RBRACE
  {:
    parser.yyerror("Missing ')'.");
  :}
  | TOK_SSCANF LPAREN expr0 COMMA expr0 error SEMICOLON
  {:
    parser.yyerror("Missing ')'.");
  :}
  | TOK_SSCANF LPAREN expr0 error RPAREN
  | TOK_SSCANF LPAREN expr0 error TOK_LEX_EOF
  {:
    parser.yyerror("Missing ')'.");
    parser.yyerror("Unexpected end of file.");
  :}
  | TOK_SSCANF LPAREN expr0 error RBRACE
  {:
    parser.yyerror("Missing ')'.");
  :}
  | TOK_SSCANF LPAREN expr0 error SEMICOLON
  {:
    parser.yyerror("Missing ')'.");
  :}
  | TOK_SSCANF LPAREN error RPAREN 
  | TOK_SSCANF LPAREN error TOK_LEX_EOF
  {:
    parser.yyerror("Missing ')'.");
    parser.yyerror("Unexpected end of file.");
  :}
  | TOK_SSCANF LPAREN error RBRACE {:  parser.yyerror("Missing ')'."); :}
  | TOK_SSCANF LPAREN error SEMICOLON {:  parser.yyerror("Missing ')'."); :}
  ;

lvalue::= expr4
  | open_bracket_with_line_info low_lvalue_list RBRACK
  | type6 TOK_IDENTIFIER
  | bad_expr_ident
  ;
low_lvalue_list::= lvalue lvalue_list 
  ;

lvalue_list::= /* empty */ 
  | COMMA lvalue lvalue_list 
  ;

string::= TOK_STRING 
  | string TOK_STRING

  ;

/*
 * Some error-handling
 */


bad_identifier::= bad_expr_ident
  | TOK_ARRAY_ID
  {: parser.yyerror("array is a reserved word."); :}
  | TOK_CLASS
  {: parser.yyerror("class is a reserved word."); :}
  | TOK_ENUM
  {: parser.yyerror("enum is a reserved word."); :}
  | TOK_FLOAT_ID
  {: parser.yyerror("float is a reserved word.");:}
  | TOK_FUNCTION_ID
  {: parser.yyerror("function is a reserved word.");:}
  | TOK_INT_ID
  {: parser.yyerror("int is a reserved word."); :}
  | TOK_MAPPING_ID
  {: parser.yyerror("mapping is a reserved word."); :}
  | TOK_MIXED_ID
  {: parser.yyerror("mixed is a reserved word."); :}
  | TOK_MULTISET_ID
  {: parser.yyerror("multiset is a reserved word."); :}
  | TOK_OBJECT_ID
  {: parser.yyerror("object is a reserved word."); :}
  | TOK_PROGRAM_ID
  {: parser.yyerror("program is a reserved word."); :}
  | TOK_STRING_ID
  {: parser.yyerror("string is a reserved word."); :}
  | TOK_TYPEDEF
  {: parser.yyerror("typedef is a reserved word."); :}
  | TOK_VOID_ID
  {: parser.yyerror("void is a reserved word."); :}
  ;

bad_expr_ident::=
    TOK_INLINE
  {: parser.yyerror("inline is a reserved word."); :}
  | TOK_LOCAL_ID
  {: parser.yyerror("local is a reserved word."); :}
  | TOK_NO_MASK
  {: parser.yyerror("nomask is a reserved word."); :}
  | TOK_PREDEF
  {: parser.yyerror("predef is a reserved word."); :}
  | TOK_PRIVATE
  {: parser.yyerror("private is a reserved word."); :}
  | TOK_PROTECTED
  {: parser.yyerror("protected is a reserved word."); :}
  | TOK_PUBLIC
  {: parser.yyerror("public is a reserved word."); :}
  | TOK_OPTIONAL
  {: parser.yyerror("optional is a reserved word."); :}
  | TOK_VARIANT
  {: parser.yyerror("variant is a reserved word."); :}
  | TOK_STATIC
  {: parser.yyerror("static is a reserved word."); :}
  | TOK_EXTERN
  {: parser.yyerror("extern is a reserved word."); :}
  | TOK_FINAL_ID
  {: parser.yyerror("final is a reserved word.");:}
  | TOK_DO
  {: parser.yyerror("do is a reserved word."); :}
  | TOK_ELSE
  {: parser.yyerror("else without if."); :}
  | TOK_RETURN
  {: parser.yyerror("return is a reserved word."); :}
  | TOK_IMPORT
  {: parser.yyerror("import is a reserved word."); :}
  | TOK_INHERIT
  {: parser.yyerror("inherit is a reserved word."); :}
  | TOK_CATCH
  {: parser.yyerror("catch is a reserved word."); :}
  | TOK_GAUGE
  {: parser.yyerror("gauge is a reserved word."); :}
  | TOK_LAMBDA
  {: parser.yyerror("lambda is a reserved word."); :}
  | TOK_SSCANF
  {: parser.yyerror("sscanf is a reserved word."); :}
  | TOK_SWITCH
  {: parser.yyerror("switch is a reserved word."); :}
  | TOK_TYPEOF
  {: parser.yyerror("typeof is a reserved word."); :}
  | TOK_BREAK
  {: parser.yyerror("break is a reserved word."); :}
  | TOK_CASE
  {: parser.yyerror("case is a reserved word."); :}
  | TOK_CONTINUE
  {: parser.yyerror("continue is a reserved word."); :}
  | TOK_DEFAULT
  {: parser.yyerror("default is a reserved word."); :}
  | TOK_FOR
  {: parser.yyerror("for is a reserved word."); :}
  | TOK_FOREACH
  {: parser.yyerror("foreach is a reserved word."); :}
  | TOK_IF
  {: parser.yyerror("if is a reserved word."); :}
  ;

